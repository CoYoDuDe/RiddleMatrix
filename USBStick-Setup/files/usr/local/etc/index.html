<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = jsonData.findIndex((row, index) =>
                  row.filter(filledCell).length >= jsonData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Boxen verwalten</title>
  <style>
    body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; }
    #sidebar {
      width: 250px; background: #333; color: white; padding: 10px; display: flex;
      flex-direction: column; justify-content: space-between;
    }
    #deviceList { flex-grow: 1; overflow-y: auto; }
    .device { padding: 8px; cursor: pointer; border-bottom: 1px solid #555; }
    .device:hover { background: #444; }
    #shutdown, #setupBtn {
      margin-top: 10px; padding: 10px; font-size: 14px; cursor: pointer;
    }
    #shutdown { background: red; color: white; }
    #setupBtn { background: #555; color: white; width: 100%; }
    #content {
      flex-grow: 1; background: #f4f4f4; padding: 0; overflow-y: auto; position: relative;
    }
    #content iframe {
      width: 100%; height: 100%; border: none;
    }
    .box-card {
      background: #fff; border: 1px solid #ccc; padding: 10px; margin-bottom: 15px;
    }
    .weekday-row {
      display: flex; gap: 8px; justify-content: space-between; flex-wrap: wrap;
    }
    .weekday-col {
      display: flex; flex-direction: column; align-items: stretch; min-width: 120px; gap: 6px;
    }
    .weekday-col select, .weekday-col input[type="color"], .weekday-col input[type="text"],
    .weekday-col input[type="number"] {
      margin-top: 4px; width: 100%; box-sizing: border-box;
    }
    .trigger-container {
      display: flex; flex-direction: column; gap: 6px; width: 100%;
    }
    .trigger-entry {
      display: flex; flex-direction: column; gap: 4px; background: #f9f9f9; padding: 4px; border-radius: 4px;
    }
    .trigger-entry span {
      font-size: 12px; font-weight: bold;
    }
    .word-input {
      margin-bottom: 10px; padding: 5px; width: 100%; max-width: 300px;
      transition: border-color 0.3s;
    }
    .word-input.pending { border: 2px solid red; }
    .word-input.saved { border: 2px solid green; }
    .delay-input.pending { border: 2px solid red; }
    .delay-input.saved { border: 2px solid green; }
    .delay-input-wrapper {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 12px;
    }
    .word-trigger-selector {
      display: flex; align-items: center; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;
    }
    .action-buttons button {
      padding: 10px; margin-right: 10px; font-size: 14px;
    }
    .status { font-weight: bold; }
    .statusEntry { margin-bottom: 5px; }
    .order-buttons button {
      padding: 5px; margin-left: 5px; font-size: 12px; cursor: pointer;
    }
    .box-order {
      font-weight: bold; margin-right: 10px;
    }
  </style>
</head>
<body onload="init()">
<div id="sidebar">
  <div>
    <h3>Märchen</h3>
    <button id="setupBtn" onclick="showSetup()">Boxen verwalten</button>
    <div id="deviceList">Lade...</div>
  </div>
  <button id="shutdown" onclick="shutdown()">Herunterfahren</button>
</div>
<div id="content"><p>Willkommen im Märchen-Manager</p></div>
<script>
let knownBoxes = {};
let connectedBoxes = [];
let transferQueue = {};
let transferring = false;
let statusArea;
let boxOrder = [];
const days = ["mo", "di", "mi", "do", "fr", "sa", "so"];
const dayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
const triggersPerDay = 3;
const defaultColor = "#ffffff";
const defaultDelay = 0;
const colorPattern = /^#[0-9A-Fa-f]{6}$/;
const letterLabels = {"*": "Sun+Rad", "#": "Sun", "~": "WIFI", "&": "Rad", "?": "Riddler"};
const letterOptions = "ABCDEFGHIJKLMNOPQRSTUVWXYZ*#~&?".split("");
let currentWordTrigger = 0;
function escapeHtml(value) {
  return String(value ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;")
    .replace(/`/g, "&#96;");
}

function sanitizeColor(color) {
  const value = typeof color === "string" ? color.trim() : "";
  if (colorPattern.test(value)) {
    return value.toLowerCase();
  }
  return defaultColor;
}

function escapeColor(color) {
  return escapeHtml(sanitizeColor(color));
}

function escapeJsString(value) {
  return escapeHtml(JSON.stringify(value ?? ""));
}

function init() {
  fetchDevices();
  setInterval(fetchDevices, 1000); // Prüfe alle 1 Sekunde
}

function normalizeBox(box) {
  box = box || {};
  box.letters = box.letters || {};
  box.colors = box.colors || {};
  box.delays = box.delays || {};
  days.forEach(day => {
    const letters = Array.isArray(box.letters[day]) ? box.letters[day].slice(0, triggersPerDay) : [];
    while (letters.length < triggersPerDay) letters.push("");
    box.letters[day] = letters;

    const colors = Array.isArray(box.colors[day]) ? box.colors[day].slice(0, triggersPerDay) : [];
    const sanitizedColors = colors.map(sanitizeColor);
    while (sanitizedColors.length < triggersPerDay) sanitizedColors.push(defaultColor);
    box.colors[day] = sanitizedColors;

    const delays = Array.isArray(box.delays[day]) ? box.delays[day].slice(0, triggersPerDay) : [];
    while (delays.length < triggersPerDay) delays.push(defaultDelay);
    box.delays[day] = delays.map(value => {
      const numeric = typeof value === "number" ? value : parseFloat(String(value).replace(",", "."));
      if (!Number.isFinite(numeric) || numeric < 0) {
        return defaultDelay;
      }
      return Math.min(999, Math.round(numeric));
    });
  });
  return box;
}

async function fetchDevices() {
  try {
    const res = await fetch("/devices");
    const data = await res.json();
    const newKnownBoxes = data.boxen || {};
    const newConnectedBoxes = data.connected || [];
    const newBoxOrder = data.boxOrder || Object.keys(newKnownBoxes);

    const normalizedIncoming = {};
    Object.entries(newKnownBoxes).forEach(([hostname, box]) => {
      normalizedIncoming[hostname] = normalizeBox(JSON.parse(JSON.stringify(box)));
    });

    // Prüfe auf Änderungen
    const hasChanges =
      JSON.stringify(knownBoxes) !== JSON.stringify(normalizedIncoming) ||
      JSON.stringify(connectedBoxes) !== JSON.stringify(newConnectedBoxes) ||
      JSON.stringify(boxOrder) !== JSON.stringify(newBoxOrder);

    knownBoxes = normalizedIncoming;
    connectedBoxes = newConnectedBoxes;
    boxOrder = newBoxOrder;

    renderDeviceList();
    const activeElement = document.activeElement;
    const isLiveEditElement = !!(activeElement && (
      (typeof activeElement.matches === "function" && activeElement.matches('[data-live-edit]')) ||
      (activeElement.classList && (activeElement.classList.contains("word-input") || activeElement.classList.contains("delay-input"))) ||
      activeElement.tagName === "SELECT"
    ));
    // Nur showSetup() aufrufen, wenn kein relevantes Eingabefeld fokussiert ist
    if (hasChanges && statusArea && !transferring && !isLiveEditElement) {
      showSetup();
    }
  } catch (e) {
    console.error("Fehler beim Abrufen der Geräte:", e);
    if (statusArea) statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Laden der Boxen.</div>';
  }
}

function renderDeviceList() {
  const list = document.getElementById("deviceList");
  list.innerHTML = connectedBoxes.length ? "" : "Keine verbundenen Boxen";
  connectedBoxes.forEach(({ hostname, ip }) => {
    const div = document.createElement("div");
    div.className = "device";
    div.innerText = `${hostname} (${ip})`;
    div.onclick = () => openBox(ip);
    list.appendChild(div);
  });
}

function openBox(ip) {
  const container = document.getElementById("content");
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
  const iframe = document.createElement("iframe");
  iframe.src = `http://${ip}`;
  container.appendChild(iframe);
}

async function shutdown() {
  if (!window.confirm("Soll das System wirklich heruntergefahren werden?")) {
    return;
  }

  const shutdownButton = document.getElementById("shutdown");
  const originalLabel = shutdownButton.textContent;
  shutdownButton.disabled = true;
  shutdownButton.textContent = "Wird heruntergefahren...";

  try {
    const response = await fetch("/shutdown", { method: "POST" });
    if (!response.ok) {
      alert("Fehler beim Abschalten: " + response.statusText);
      return;
    }
    let message = "Shutdown ausgelöst.";
    try {
      const data = await response.json();
      if (data && data.status) {
        message = "Shutdown ausgelöst (" + data.status + ").";
      }
    } catch (e) {
      // JSON optional
    }
    alert(message + " Das Gerät kann einige Minuten zum Herunterfahren benötigen.");
  } catch (error) {
    console.error(error);
    alert("Netzwerkfehler beim Abschalten. Bitte erneut versuchen.");
  } finally {
    shutdownButton.disabled = false;
    shutdownButton.textContent = originalLabel;
  }
}

function showSetup() {
  let html = '<h2>Boxen verwalten</h2>';
  const maxLength = boxOrder.length;

  html += '<div class="box-card"><h3>Wörter für Wochentage</h3>';
  html += '<div class="word-trigger-selector">';
  html += '<label for="wordTriggerSelect">Trigger-Spalte:</label>';
  html += '<select id="wordTriggerSelect" data-live-edit="true" onchange="changeWordTrigger(parseInt(this.value, 10))">';
  for (let trigger = 0; trigger < triggersPerDay; trigger++) {
    const selected = trigger === currentWordTrigger ? "selected" : "";
    html += `<option value="${trigger}" ${selected}>Trigger ${trigger + 1}</option>`;
  }
  html += '</select></div>';

  html += '<div class="weekday-row">';
  for (let i = 0; i < days.length; i++) {
    const currentWord = boxOrder.map(hostname => {
      const letters = knownBoxes[hostname]?.letters?.[days[i]] || [];
      return letters[currentWordTrigger] || "";
    }).join("");
    html += `
      <div class="weekday-col">
        <label>${dayNames[i]}</label>
        <input type="text" class="word-input" data-live-edit="true" placeholder="Wort eingeben (max ${maxLength} Zeichen)"
          value="${currentWord}" onchange="updateWord('${days[i]}', this.value, ${maxLength}, this)"
          onkeydown="handleKeydown(event, '${days[i]}', this.value, ${maxLength}, this)">
      </div>`;
  }
  html += '</div></div>';

  boxOrder.forEach((hostname, index) => {
    const box = normalizeBox(knownBoxes[hostname] || {});
    const escapedHostname = escapeHtml(hostname);
    const hostnameArgument = escapeJsString(hostname);
    html += `<div class="box-card"><h3><span class="box-order">${index + 1}</span>${escapedHostname}</h3><div class="weekday-row">`;
    for (let i = 0; i < days.length; i++) {
      const letters = box.letters?.[days[i]] || [];
      const colors = box.colors?.[days[i]] || [];
      const delays = box.delays?.[days[i]] || [];
      html += `
        <div class="weekday-col">
          <label>${dayNames[i]}</label>
          <div class="trigger-container">`;
      for (let trigger = 0; trigger < triggersPerDay; trigger++) {
        const letter = letters[trigger] || "";
        const color = sanitizeColor(colors[trigger] || defaultColor);
        const rawDelay = delays[trigger];
        const parsedDelay = typeof rawDelay === "number" ? rawDelay : parseFloat(String(rawDelay).replace(",", "."));
        const delayValue = Number.isFinite(parsedDelay) && parsedDelay >= 0
          ? Math.min(999, Math.round(parsedDelay))
          : defaultDelay;
        const delayDisplay = delayValue.toString();
        const letterOptionsHtml = letterOptions.map(c =>
          `<option value="${c}" ${c === letter ? "selected" : ""}>${letterLabels[c] || c}</option>`).join("");
        html += `
            <div class="trigger-entry">
              <span>Trigger ${trigger + 1}</span>
              <select data-live-edit="true" onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'letter')" onfocus="this.size='7'" onblur="this.size='1'" onclick="event.stopPropagation();">
                ${letterOptionsHtml}
              </select>
              <input type="color" data-live-edit="true" value="${escapeColor(color)}" onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'color')">
              <div class="delay-input-wrapper">
                <span>Verzögerung (s)</span>
                <input type="number" class="delay-input" data-live-edit="true" min="0" max="999" step="1" inputmode="numeric" pattern="\\d*" value="${delayDisplay}" onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'delay', true, this)">
              </div>
            </div>`;
      }
      html += `
          </div>
        </div>`;
    }
    html += `</div>
      <div class="order-buttons">
        <button onclick="moveBoxUp(${hostnameArgument})">↑</button>
        <button onclick="moveBoxDown(${hostnameArgument})">↓</button>
        <button onclick="removeBox(${hostnameArgument})">❌ Entfernen</button>
      </div></div>`;
  });

  html += `
  <div class="action-buttons">
    <button onclick="transferAll()" id="transferBtn">✅ Übertragen</button>
    <button onclick="reloadAll()" id="reloadBtn">🔄 Boxen neu lernen</button>
  </div>
  <div id="statusArea"></div>
  `;

  document.getElementById("content").innerHTML = html;
  statusArea = document.getElementById("statusArea");
}

function handleKeydown(event, day, word, maxLength, inputElement) {
  if (event.key === "Enter") {
    updateWord(day, word, maxLength, inputElement);
  }
}

function updateWord(day, word, maxLength, inputElement) {
  if (inputElement) {
    inputElement.classList.add("pending");
  }
  const sanitizedWord = (word || "").toUpperCase().replace(/[^A-Z*#~&?]/g, '').slice(0, maxLength);
  word = sanitizedWord;
  if (inputElement) {
    inputElement.value = sanitizedWord;
  }
  for (let i = 0; i < boxOrder.length; i++) {
    const letter = i < word.length ? word[i] : "*";
    knownBoxes[boxOrder[i]] = knownBoxes[boxOrder[i]] || {};
    saveField(boxOrder[i], day, currentWordTrigger, letter, 'letter', false, inputElement);
  }
  showSetup();
}

function saveField(hostname, day, triggerIndex, value, fieldType = 'letter', updateUI = true, inputElement = null) {
  if (inputElement) {
    inputElement.classList.add('pending');
  }

  knownBoxes[hostname] = normalizeBox(knownBoxes[hostname] || {});
  const slotIndex = Number(triggerIndex);
  if (fieldType === 'letter') {
    knownBoxes[hostname].letters[day][slotIndex] = value;
  } else if (fieldType === 'color') {
    const colorValue = sanitizeColor(value);
    knownBoxes[hostname].colors[day][slotIndex] = colorValue;
    value = colorValue;
  } else if (fieldType === 'delay') {
    let numericValue = typeof value === 'number' ? value : parseFloat(String(value).replace(",", "."));
    if (!Number.isFinite(numericValue) || numericValue < 0) {
      numericValue = defaultDelay;
    }
    numericValue = Math.min(999, Math.max(0, Math.round(numericValue)));
    knownBoxes[hostname].delays[day][slotIndex] = numericValue;
    value = numericValue;
    if (inputElement) {
      inputElement.value = numericValue.toString();
    }
  }

  const payload = { hostname, day, triggerIndex: slotIndex };
  if (fieldType === 'letter') {
    payload.letter = value;
  } else if (fieldType === 'color') {
    payload.color = sanitizeColor(value);
  } else if (fieldType === 'delay') {
    payload.delay = value;
  }

  const requestHeaders = { "Content-Type": "application/json" };

  fetch("/update_box", {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify(payload)
  }).then(response => {
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichen.</div>';
      if (inputElement) inputElement.classList.remove("pending");
    } else {
      if (inputElement) {
        inputElement.classList.remove("pending");
        inputElement.classList.add("saved");
        setTimeout(() => inputElement.classList.remove("saved"), 1000);
        statusArea.innerHTML = '<div class="statusEntry status">✅ Änderung gespeichert.</div>';
      }
      if (updateUI) showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Speichern:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern.</div>';
    if (inputElement) inputElement.classList.remove("pending");
  });
}

function changeWordTrigger(newTrigger) {
  if (!Number.isInteger(newTrigger)) {
    newTrigger = parseInt(newTrigger, 10);
  }
  if (Number.isNaN(newTrigger) || newTrigger < 0 || newTrigger >= triggersPerDay) {
    return;
  }
  currentWordTrigger = newTrigger;
  showSetup();
}

function moveBoxUp(hostname) {
  const index = boxOrder.indexOf(hostname);
  if (index > 0) {
    [boxOrder[index - 1], boxOrder[index]] = [boxOrder[index], boxOrder[index - 1]];
    saveBoxOrder();
  }
}

function moveBoxDown(hostname) {
  const index = boxOrder.indexOf(hostname);
  if (index < boxOrder.length - 1) {
    [boxOrder[index], boxOrder[index + 1]] = [boxOrder[index + 1], boxOrder[index]];
    saveBoxOrder();
  }
}

function saveBoxOrder() {
  const requestHeaders = { "Content-Type": "application/json" };

  fetch("/update_box_order", {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify({ boxOrder })
  }).then(response => {
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern der Reihenfolge.</div>';
    } else {
      showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Speichern der Reihenfolge:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern der Reihenfolge.</div>';
  });
}

function removeBox(hostname) {
  const headers = { "Content-Type": "application/json" };

  fetch("/remove_box", {
    method: "POST",
    headers,
    body: JSON.stringify({ hostname })
  }).then(response => {
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Entfernen.</div>';
    } else {
      showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Entfernen:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Entfernen.</div>';
  });
}

async function transferBox(hostname) {
  const headers = { "Content-Type": "application/json" };

  transferQueue[hostname] = true;
  const transferBtn = document.getElementById("transferBtn");
  if (!transferring) {
    transferring = true;
    transferBtn.disabled = true;
    transferBtn.innerText = "Übertrage...";
  }

  let statusText = "❌ Unbekannter Fehler";

  try {
    const response = await fetch("/transfer_box", {
      method: "POST",
      headers,
      body: JSON.stringify({ hostname })
    });

    if (!response.ok) {
      statusText = `❌ Fehler (${response.status})`;
    } else {
      const data = await response.json();
      statusText = data.status || "❌ Unerwartete Antwort";
    }
  } catch (error) {
    console.error("Fehler beim Übertragen:", error);
    statusText = "❌ Netzwerkfehler";
  } finally {
    delete transferQueue[hostname];
    if (Object.keys(transferQueue).length === 0) {
      transferring = false;
      transferBtn.disabled = false;
      transferBtn.innerText = "✅ Übertragen";
    }
    statusArea.innerHTML += `<div class="statusEntry">${escapeHtml(hostname)}: ${statusText}</div>`;
    setTimeout(() => {
      if (statusArea.firstChild) {
        statusArea.removeChild(statusArea.firstChild);
      }
    }, 3000);
  }
}

function transferAll() {
  boxOrder.forEach(transferBox);
}

async function reloadAll() {
  if (!window.confirm("Sollen alle Boxen wirklich neu eingelesen werden?")) {
    return;
  }

  const reloadButton = document.getElementById("reloadBtn");
  const originalLabel = reloadButton ? reloadButton.textContent : "";
  if (reloadButton) {
    reloadButton.disabled = true;
    reloadButton.textContent = "Lade Geräte...";
  }

  try {
    const response = await fetch("/reload_all", { method: "POST" });
    if (!response.ok) {
      alert("Fehler beim Neu-Laden der Boxen: " + response.statusText);
      return;
    }
    await fetchDevices();
    alert("Die Boxen wurden neu eingelesen.");
  } catch (error) {
    console.error("Fehler beim Neu-Laden:", error);
    alert("Netzwerkfehler beim Neu-Laden. Bitte erneut versuchen.");
  } finally {
    if (reloadButton) {
      reloadButton.textContent = originalLabel || "🔄 Boxen neu lernen";
      reloadButton.disabled = false;
    }
  }
}
</script>
</body>
</html>
