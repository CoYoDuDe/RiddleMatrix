<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = jsonData.findIndex((row, index) =>
                  row.filter(filledCell).length >= jsonData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
</script>
<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Boxen verwalten</title>
  <style>
    body { font-family: sans-serif; margin: 0; display: flex; height: 100vh; }
    #sidebar {
      width: 250px; background: #333; color: white; padding: 10px; display: flex;
      flex-direction: column; justify-content: space-between;
    }
    #deviceList { flex-grow: 1; overflow-y: auto; }
    .device { padding: 8px; cursor: pointer; border-bottom: 1px solid #555; }
    .device:hover { background: #444; }
    #shutdown, #setupBtn {
      margin-top: 10px; padding: 10px; font-size: 14px; cursor: pointer;
    }
    #shutdown { background: red; color: white; }
    #setupBtn { background: #555; color: white; width: 100%; }
    #content {
      flex-grow: 1; background: #f4f4f4; padding: 0; overflow-y: auto; position: relative;
    }
    #content iframe {
      width: 100%; height: 100%; border: none;
    }
    .box-card {
      background: #fff; border: 1px solid #ccc; padding: 10px; margin-bottom: 15px;
    }
    .weekday-row {
      display: flex; gap: 8px; justify-content: space-between; flex-wrap: wrap;
    }
    .weekday-col {
      display: flex; flex-direction: column; align-items: stretch; min-width: 120px; gap: 6px;
    }
    .weekday-col select, .weekday-col input[type="color"], .weekday-col input[type="text"],
    .weekday-col input[type="number"] {
      margin-top: 4px; width: 100%; box-sizing: border-box;
    }
    .trigger-container {
      display: flex; flex-direction: column; gap: 6px; width: 100%;
    }
    .trigger-entry {
      display: flex; flex-direction: column; gap: 4px; background: #f9f9f9; padding: 4px; border-radius: 4px;
    }
    .trigger-entry span {
      font-size: 12px; font-weight: bold;
    }
    .word-input {
      margin-bottom: 10px; padding: 5px; width: 100%; max-width: 300px;
      transition: border-color 0.3s;
    }
    .word-input.pending { border: 2px solid red; }
    .word-input.saved { border: 2px solid green; }
    .delay-input.pending { border: 2px solid red; }
    .delay-input.saved { border: 2px solid green; }
    .delay-input-wrapper {
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 12px;
    }
    .word-trigger-selector {
      display: flex; align-items: center; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;
    }
    .action-buttons button {
      padding: 10px; margin-right: 10px; font-size: 14px;
    }
    .status { font-weight: bold; }
    .statusEntry { margin-bottom: 5px; }
    .order-buttons button {
      padding: 5px; margin-left: 5px; font-size: 12px; cursor: pointer;
    }
    .box-order {
      font-weight: bold; margin-right: 10px;
    }
    .auth-notice {
      margin: 10px 0;
      padding: 8px 12px;
      border-radius: 4px;
      font-weight: bold;
    }
    .auth-notice.unauthorized {
      background: #fff4d6;
      color: #8a5200;
    }
    .auth-notice.authorized {
      background: #e6ffed;
      color: #0b6b3a;
    }
    .auth-disabled {
      opacity: 0.5;
    }
  </style>
</head>
<body onload="init()">
<div id="sidebar">
  <div>
    <h3>Märchen</h3>
    <button id="setupBtn" onclick="showSetup()">Boxen verwalten</button>
    <div id="deviceList">Lade...</div>
  </div>
  <button id="shutdown" onclick="shutdown()">Herunterfahren</button>
</div>
<div id="content"><p>Willkommen im Märchen-Manager</p></div>
<script>
let knownBoxes = {};
let connectedBoxes = [];
let transferQueue = {};
let transferring = false;
let statusArea;
let boxOrder = [];
const days = ["mo", "di", "mi", "do", "fr", "sa", "so"];
const dayNames = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
const triggersPerDay = 3;
const defaultColor = "#ffffff";
const defaultDelay = 0;
const letterLabels = {"*": "Sun+Rad", "#": "Sun", "~": "WIFI", "&": "Rad", "?": "Riddler"};
const letterOptions = "ABCDEFGHIJKLMNOPQRSTUVWXYZ*#~&?".split("");
let currentWordTrigger = 0;
const loopbackHosts = new Set(["localhost", "127.0.0.1", "::1"]);
const adminTokenStorageKey = "shutdownToken";
const sensitiveHeaderName = "X-Api-Key";
const AUTH_REQUIRED_MESSAGE = "🔒 Administrations-Token erforderlich – Änderungen sind gesperrt.";

function escapeHtml(value) {
  return String(value ?? "")
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;")
    .replace(/`/g, "&#96;");
}

function escapeJsString(value) {
  return escapeHtml(JSON.stringify(value ?? ""));
}

function requiresAdminToken() {
  return !loopbackHosts.has(window.location.hostname);
}

function getStoredAdminToken() {
  return localStorage.getItem(adminTokenStorageKey) || "";
}

function requestAdminToken() {
  const token = prompt("Bitte Administrations-Token eingeben:");
  if (token == null) {
    return "";
  }
  const trimmed = token.trim();
  if (trimmed) {
    localStorage.setItem(adminTokenStorageKey, trimmed);
  }
  return trimmed;
}

function ensureAdminToken() {
  let token = getStoredAdminToken();
  if (token) {
    return token;
  }
  token = requestAdminToken();
  return token;
}

function clearAdminToken() {
  localStorage.removeItem(adminTokenStorageKey);
  updateReloadButtonState();
}

function notifyAuthRequired(showAlert = false) {
  if (statusArea) {
    statusArea.innerHTML = `<div class="statusEntry status">${AUTH_REQUIRED_MESSAGE}</div>`;
    statusArea.dataset.authState = "unauthorized";
  }
  if (showAlert) {
    alert(AUTH_REQUIRED_MESSAGE);
  }
  updateReloadButtonState();
}

function isSessionAuthorized() {
  if (!requiresAdminToken()) {
    return true;
  }
  return !!getStoredAdminToken();
}

function updateReloadButtonState() {
  const authorized = isSessionAuthorized();
  const reloadButton = document.getElementById("reloadBtn");
  if (reloadButton) {
    reloadButton.disabled = !authorized;
    reloadButton.title = authorized ? "" : "Authentifizierung erforderlich – Token hinterlegen";
  }

  const authNotice = document.getElementById("authNotice");
  if (authNotice) {
    authNotice.textContent = authorized
      ? "🔓 Administrationsfunktionen freigeschaltet."
      : AUTH_REQUIRED_MESSAGE;
    authNotice.classList.toggle("authorized", authorized);
    authNotice.classList.toggle("unauthorized", !authorized);
  }

  const requiresAuthElements = document.querySelectorAll("[data-requires-auth]");
  requiresAuthElements.forEach(element => {
    if ("disabled" in element) {
      element.disabled = !authorized;
    }
    element.classList.toggle("auth-disabled", !authorized);
  });

  if (statusArea) {
    if (!authorized) {
      if (statusArea.dataset.authState !== "unauthorized") {
        statusArea.innerHTML = `<div class="statusEntry status">${AUTH_REQUIRED_MESSAGE}</div>`;
        statusArea.dataset.authState = "unauthorized";
      }
    } else if (statusArea.dataset.authState === "unauthorized") {
      statusArea.innerHTML = "";
      delete statusArea.dataset.authState;
    }
  }
}

function configureAdminToken() {
  const token = requestAdminToken();
  if (token) {
    alert("Token gespeichert. Geschützte Aktionen wurden freigeschaltet.");
  } else {
    alert("Kein Token hinterlegt. Geschützte Aktionen bleiben gesperrt.");
  }
  updateReloadButtonState();
}

function buildSensitiveHeaders(options = { prompt: false }) {
  const headers = {};
  if (!requiresAdminToken()) {
    return headers;
  }
  const token = options.prompt ? ensureAdminToken() : getStoredAdminToken();
  if (!token) {
    return null;
  }
  headers[sensitiveHeaderName] = token;
  return headers;
}

function init() {
  fetchDevices();
  setInterval(fetchDevices, 1000); // Prüfe alle 1 Sekunde
}

function normalizeBox(box) {
  box = box || {};
  box.letters = box.letters || {};
  box.colors = box.colors || {};
  box.delays = box.delays || {};
  days.forEach(day => {
    const letters = Array.isArray(box.letters[day]) ? box.letters[day].slice(0, triggersPerDay) : [];
    while (letters.length < triggersPerDay) letters.push("");
    box.letters[day] = letters;

    const colors = Array.isArray(box.colors[day]) ? box.colors[day].slice(0, triggersPerDay) : [];
    while (colors.length < triggersPerDay) colors.push(defaultColor);
    box.colors[day] = colors;

    const delays = Array.isArray(box.delays[day]) ? box.delays[day].slice(0, triggersPerDay) : [];
    while (delays.length < triggersPerDay) delays.push(defaultDelay);
    box.delays[day] = delays.map(value => {
      const numeric = typeof value === "number" ? value : parseFloat(String(value).replace(",", "."));
      if (!Number.isFinite(numeric) || numeric < 0) {
        return defaultDelay;
      }
      return Math.min(999, Math.round(numeric));
    });
  });
  return box;
}

async function fetchDevices() {
  try {
    const res = await fetch("/devices");
    const data = await res.json();
    const newKnownBoxes = data.boxen || {};
    const newConnectedBoxes = data.connected || [];
    const newBoxOrder = data.boxOrder || Object.keys(newKnownBoxes);

    const normalizedIncoming = {};
    Object.entries(newKnownBoxes).forEach(([hostname, box]) => {
      normalizedIncoming[hostname] = normalizeBox(JSON.parse(JSON.stringify(box)));
    });

    // Prüfe auf Änderungen
    const hasChanges =
      JSON.stringify(knownBoxes) !== JSON.stringify(normalizedIncoming) ||
      JSON.stringify(connectedBoxes) !== JSON.stringify(newConnectedBoxes) ||
      JSON.stringify(boxOrder) !== JSON.stringify(newBoxOrder);

    knownBoxes = normalizedIncoming;
    connectedBoxes = newConnectedBoxes;
    boxOrder = newBoxOrder;

    renderDeviceList();
    // Nur showSetup() aufrufen, wenn kein Textfeld oder Dropdown-Menü fokussiert ist
    if (hasChanges && statusArea && !transferring &&
        !document.activeElement.classList.contains("word-input") &&
        !document.activeElement.classList.contains("delay-input") &&
        document.activeElement.tagName !== "SELECT") {
      showSetup();
    }
  } catch (e) {
    console.error("Fehler beim Abrufen der Geräte:", e);
    if (statusArea) statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Laden der Boxen.</div>';
  }
}

function renderDeviceList() {
  const list = document.getElementById("deviceList");
  list.innerHTML = connectedBoxes.length ? "" : "Keine verbundenen Boxen";
  connectedBoxes.forEach(({ hostname, ip }) => {
    const div = document.createElement("div");
    div.className = "device";
    div.innerText = `${hostname} (${ip})`;
    div.onclick = () => openBox(ip);
    list.appendChild(div);
  });
}

function openBox(ip) {
  document.getElementById("content").innerHTML = `<iframe src="http://${ip}"></iframe>`;
}

async function shutdown() {
  if (!window.confirm("Soll das System wirklich heruntergefahren werden?")) {
    return;
  }

  const headers = buildSensitiveHeaders({ prompt: true });
  if (headers === null) {
    alert("Herunterfahren abgebrochen – kein Token hinterlegt.");
    return;
  }
  if (requiresAdminToken()) {
    const token = headers[sensitiveHeaderName];
    if (!token) {
      alert("Herunterfahren abgebrochen – kein Token hinterlegt.");
      return;
    }
  }

  const shutdownButton = document.getElementById("shutdown");
  const originalLabel = shutdownButton.textContent;
  shutdownButton.disabled = true;
  shutdownButton.textContent = "Wird heruntergefahren...";

  try {
    const response = await fetch("/shutdown", { method: "POST", headers });
    if (response.status === 401 || response.status === 403) {
      clearAdminToken();
      alert("Authentifizierung fehlgeschlagen. Bitte Administrations-Token prüfen.");
      updateReloadButtonState();
      return;
    }
    if (!response.ok) {
      alert("Fehler beim Abschalten: " + response.statusText);
      return;
    }
    let message = "Shutdown ausgelöst.";
    try {
      const data = await response.json();
      if (data && data.status) {
        message = "Shutdown ausgelöst (" + data.status + ").";
      }
    } catch (e) {
      // JSON optional
    }
    alert(message + " Das Gerät kann einige Minuten zum Herunterfahren benötigen.");
  } catch (error) {
    console.error(error);
    alert("Netzwerkfehler beim Abschalten. Bitte erneut versuchen.");
  } finally {
    shutdownButton.disabled = false;
    shutdownButton.textContent = originalLabel;
  }
}

function showSetup() {
  let html = '<h2>Boxen verwalten</h2>';
  const maxLength = boxOrder.length;
  const authorized = isSessionAuthorized();
  const authMessage = authorized ? "🔓 Administrationsfunktionen freigeschaltet." : AUTH_REQUIRED_MESSAGE;

  html += `<div id="authNotice" class="auth-notice ${authorized ? "authorized" : "unauthorized"}">${authMessage}</div>`;

  html += '<div class="box-card"><h3>Wörter für Wochentage</h3>';
  html += '<div class="word-trigger-selector">';
  html += '<label for="wordTriggerSelect">Trigger-Spalte:</label>';
  html += '<select id="wordTriggerSelect" onchange="changeWordTrigger(parseInt(this.value, 10))" data-requires-auth="true">';
  for (let trigger = 0; trigger < triggersPerDay; trigger++) {
    const selected = trigger === currentWordTrigger ? "selected" : "";
    html += `<option value="${trigger}" ${selected}>Trigger ${trigger + 1}</option>`;
  }
  html += '</select></div>';

  html += '<div class="weekday-row">';
  for (let i = 0; i < days.length; i++) {
    const currentWord = boxOrder.map(hostname => {
      const letters = knownBoxes[hostname]?.letters?.[days[i]] || [];
      return letters[currentWordTrigger] || "";
    }).join("");
    html += `
      <div class="weekday-col">
        <label>${dayNames[i]}</label>
        <input type="text" class="word-input" placeholder="Wort eingeben (max ${maxLength} Zeichen)"
          value="${currentWord}" onchange="updateWord('${days[i]}', this.value, ${maxLength}, this)"
          data-requires-auth="true"
          onkeydown="handleKeydown(event, '${days[i]}', this.value, ${maxLength}, this)">
      </div>`;
  }
  html += '</div></div>';

  boxOrder.forEach((hostname, index) => {
    const box = normalizeBox(knownBoxes[hostname] || {});
    const escapedHostname = escapeHtml(hostname);
    const hostnameArgument = escapeJsString(hostname);
    html += `<div class="box-card"><h3><span class="box-order">${index + 1}</span>${escapedHostname}</h3><div class="weekday-row">`;
    for (let i = 0; i < days.length; i++) {
      const letters = box.letters?.[days[i]] || [];
      const colors = box.colors?.[days[i]] || [];
      const delays = box.delays?.[days[i]] || [];
      html += `
        <div class="weekday-col">
          <label>${dayNames[i]}</label>
          <div class="trigger-container">`;
      for (let trigger = 0; trigger < triggersPerDay; trigger++) {
        const letter = letters[trigger] || "";
        const color = colors[trigger] || defaultColor;
        const rawDelay = delays[trigger];
        const parsedDelay = typeof rawDelay === "number" ? rawDelay : parseFloat(String(rawDelay).replace(",", "."));
        const delayValue = Number.isFinite(parsedDelay) && parsedDelay >= 0
          ? Math.min(999, Math.round(parsedDelay))
          : defaultDelay;
        const delayDisplay = delayValue.toString();
        const letterOptionsHtml = letterOptions.map(c =>
          `<option value="${c}" ${c === letter ? "selected" : ""}>${letterLabels[c] || c}</option>`).join("");
        html += `
            <div class="trigger-entry">
              <span>Trigger ${trigger + 1}</span>
              <select onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'letter')" onfocus="this.size='7'" onblur="this.size='1'" onclick="event.stopPropagation();" data-requires-auth="true">
                ${letterOptionsHtml}
              </select>
              <input type="color" value="${color}" onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'color')" data-requires-auth="true">
              <div class="delay-input-wrapper">
                <span>Verzögerung (s)</span>
                <input type="number" class="delay-input" min="0" max="999" step="1" inputmode="numeric" pattern="\\d*" value="${delayDisplay}" onchange="saveField(${hostnameArgument}, '${days[i]}', ${trigger}, this.value, 'delay', true, this)" data-requires-auth="true">
              </div>
            </div>`;
      }
      html += `
          </div>
        </div>`;
    }
    html += `</div>
      <div class="order-buttons">
        <button onclick="moveBoxUp(${hostnameArgument})" data-requires-auth="true">↑</button>
        <button onclick="moveBoxDown(${hostnameArgument})" data-requires-auth="true">↓</button>
        <button onclick="removeBox(${hostnameArgument})" data-requires-auth="true">❌ Entfernen</button>
      </div></div>`;
  });

  html += `
  <div class="action-buttons">
    <button onclick="transferAll()" id="transferBtn" data-requires-auth="true">✅ Übertragen</button>
    <button onclick="reloadAll()" id="reloadBtn" data-requires-auth="true">🔄 Boxen neu lernen</button>
    <button onclick="configureAdminToken()" id="authBtn">🔐 Zugang hinterlegen</button>
  </div>
  <div id="statusArea"></div>
  `;

  document.getElementById("content").innerHTML = html;
  statusArea = document.getElementById("statusArea");
  updateReloadButtonState();
}

function handleKeydown(event, day, word, maxLength, inputElement) {
  if (event.key === "Enter") {
    updateWord(day, word, maxLength, inputElement);
  }
}

function updateWord(day, word, maxLength, inputElement) {
  if (inputElement) {
    inputElement.classList.add("pending");
  }
  const sanitizedWord = (word || "").toUpperCase().replace(/[^A-Z*#~&?]/g, '').slice(0, maxLength);
  const headers = buildSensitiveHeaders({ prompt: true });
  if (headers === null) {
    if (inputElement) {
      inputElement.classList.remove("pending");
    }
    notifyAuthRequired();
    showSetup();
    return;
  }
  word = sanitizedWord;
  if (inputElement) {
    inputElement.value = sanitizedWord;
  }
  for (let i = 0; i < boxOrder.length; i++) {
    const letter = i < word.length ? word[i] : "*";
    knownBoxes[boxOrder[i]] = knownBoxes[boxOrder[i]] || {};
    saveField(boxOrder[i], day, currentWordTrigger, letter, 'letter', false, inputElement, headers);
  }
  showSetup();
}

function saveField(hostname, day, triggerIndex, value, fieldType = 'letter', updateUI = true, inputElement = null, headersOverride) {
  if (inputElement) {
    inputElement.classList.add('pending');
  }

  let headers = headersOverride;
  if (headers === undefined) {
    headers = buildSensitiveHeaders({ prompt: true });
  }
  if (headers === null) {
    if (inputElement) {
      inputElement.classList.remove('pending');
    }
    notifyAuthRequired();
    showSetup();
    return;
  }

  knownBoxes[hostname] = normalizeBox(knownBoxes[hostname] || {});
  const slotIndex = Number(triggerIndex);
  if (fieldType === 'letter') {
    knownBoxes[hostname].letters[day][slotIndex] = value;
  } else if (fieldType === 'color') {
    const colorValue = value || defaultColor;
    knownBoxes[hostname].colors[day][slotIndex] = colorValue;
    value = colorValue;
  } else if (fieldType === 'delay') {
    let numericValue = typeof value === 'number' ? value : parseFloat(String(value).replace(",", "."));
    if (!Number.isFinite(numericValue) || numericValue < 0) {
      numericValue = defaultDelay;
    }
    numericValue = Math.min(999, Math.max(0, Math.round(numericValue)));
    knownBoxes[hostname].delays[day][slotIndex] = numericValue;
    value = numericValue;
    if (inputElement) {
      inputElement.value = numericValue.toString();
    }
  }

  const payload = { hostname, day, triggerIndex: slotIndex };
  if (fieldType === 'letter') {
    payload.letter = value;
  } else if (fieldType === 'color') {
    payload.color = value;
  } else if (fieldType === 'delay') {
    payload.delay = value;
  }

  const requestHeaders = { ...headers, "Content-Type": "application/json" };

  fetch("/update_box", {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify(payload)
  }).then(response => {
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichen.</div>';
      if (statusArea) {
        delete statusArea.dataset.authState;
      }
      if (inputElement) inputElement.classList.remove("pending");
    } else {
      if (inputElement) {
        inputElement.classList.remove("pending");
        inputElement.classList.add("saved");
        setTimeout(() => inputElement.classList.remove("saved"), 1000);
        statusArea.innerHTML = '<div class="statusEntry status">✅ Änderung gespeichert.</div>';
      }
      if (statusArea) {
        delete statusArea.dataset.authState;
      }
      if (updateUI) showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Speichern:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern.</div>';
    if (statusArea) {
      delete statusArea.dataset.authState;
    }
    if (inputElement) inputElement.classList.remove("pending");
  });
}

function changeWordTrigger(newTrigger) {
  if (!Number.isInteger(newTrigger)) {
    newTrigger = parseInt(newTrigger, 10);
  }
  if (Number.isNaN(newTrigger) || newTrigger < 0 || newTrigger >= triggersPerDay) {
    return;
  }
  currentWordTrigger = newTrigger;
  showSetup();
}

function moveBoxUp(hostname) {
  const index = boxOrder.indexOf(hostname);
  if (index > 0) {
    [boxOrder[index - 1], boxOrder[index]] = [boxOrder[index], boxOrder[index - 1]];
    saveBoxOrder();
  }
}

function moveBoxDown(hostname) {
  const index = boxOrder.indexOf(hostname);
  if (index < boxOrder.length - 1) {
    [boxOrder[index], boxOrder[index + 1]] = [boxOrder[index + 1], boxOrder[index]];
    saveBoxOrder();
  }
}

function saveBoxOrder() {
  const headers = buildSensitiveHeaders({ prompt: true });
  if (headers === null) {
    notifyAuthRequired();
    fetchDevices();
    return;
  }
  const requestHeaders = { ...headers, "Content-Type": "application/json" };

  fetch("/update_box_order", {
    method: "POST",
    headers: requestHeaders,
    body: JSON.stringify({ boxOrder })
  }).then(response => {
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern der Reihenfolge.</div>';
    } else {
      showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Speichern der Reihenfolge:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Speichern der Reihenfolge.</div>';
  });
}

function removeBox(hostname) {
  const headers = buildSensitiveHeaders({ prompt: true });
  if (headers === null) {
    const message = '⚠️ Entfernen abgebrochen – Administrations-Token erforderlich.';
    if (statusArea) {
      statusArea.innerHTML = `<div class="statusEntry status">${message}</div>`;
    }
    alert(message);
    return;
  }

  headers["Content-Type"] = "application/json";

  fetch("/remove_box", {
    method: "POST",
    headers,
    body: JSON.stringify({ hostname })
  }).then(response => {
    if (response.status === 401 || response.status === 403) {
      clearAdminToken();
      const message = '❌ Zugriff verweigert – bitte Token prüfen.';
      if (statusArea) {
        statusArea.innerHTML = `<div class="statusEntry status">${message}</div>`;
      }
      alert(message);
      return;
    }
    if (!response.ok) {
      statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Entfernen.</div>';
    } else {
      showSetup();
    }
  }).catch(e => {
    console.error("Fehler beim Entfernen:", e);
    statusArea.innerHTML = '<div class="statusEntry status">❌ Fehler beim Entfernen.</div>';
  });
}

async function transferBox(hostname) {
  const headers = buildSensitiveHeaders({ prompt: true });
  if (headers === null) {
    alert("Übertragung abgebrochen – kein Administrations-Token hinterlegt.");
    return;
  }
  headers["Content-Type"] = "application/json";

  transferQueue[hostname] = true;
  const transferBtn = document.getElementById("transferBtn");
  if (!transferring) {
    transferring = true;
    transferBtn.disabled = true;
    transferBtn.innerText = "Übertrage...";
  }

  let statusText = "❌ Unbekannter Fehler";

  try {
    const response = await fetch("/transfer_box", {
      method: "POST",
      headers,
      body: JSON.stringify({ hostname })
    });

    if (response.status === 401 || response.status === 403) {
      clearAdminToken();
      statusText = "❌ Zugriff verweigert";
    } else if (!response.ok) {
      statusText = `❌ Fehler (${response.status})`;
    } else {
      const data = await response.json();
      statusText = data.status || "❌ Unerwartete Antwort";
    }
  } catch (error) {
    console.error("Fehler beim Übertragen:", error);
    statusText = "❌ Netzwerkfehler";
  } finally {
    delete transferQueue[hostname];
    if (Object.keys(transferQueue).length === 0) {
      transferring = false;
      transferBtn.disabled = false;
      transferBtn.innerText = "✅ Übertragen";
    }
    statusArea.innerHTML += `<div class="statusEntry">${escapeHtml(hostname)}: ${statusText}</div>`;
    setTimeout(() => {
      if (statusArea.firstChild) {
        statusArea.removeChild(statusArea.firstChild);
      }
    }, 3000);
  }
}

function transferAll() {
  boxOrder.forEach(transferBox);
}

async function reloadAll() {
  if (!window.confirm("Sollen alle Boxen wirklich neu eingelesen werden?")) {
    return;
  }

  const headers = buildSensitiveHeaders();
  if (headers === null) {
    alert("Vorgang abgebrochen – kein Administrations-Token hinterlegt.");
    updateReloadButtonState();
    return;
  }

  const reloadButton = document.getElementById("reloadBtn");
  const originalLabel = reloadButton ? reloadButton.textContent : "";
  if (reloadButton) {
    reloadButton.disabled = true;
    reloadButton.textContent = "Lade Geräte...";
  }

  try {
    const response = await fetch("/reload_all", { method: "POST", headers });
    if (response.status === 401 || response.status === 403) {
      clearAdminToken();
      alert("Authentifizierung fehlgeschlagen. Bitte Administrations-Token prüfen.");
      return;
    }
    if (!response.ok) {
      alert("Fehler beim Neu-Laden der Boxen: " + response.statusText);
      return;
    }
    await fetchDevices();
    alert("Die Boxen wurden neu eingelesen.");
  } catch (error) {
    console.error("Fehler beim Neu-Laden:", error);
    alert("Netzwerkfehler beim Neu-Laden. Bitte erneut versuchen.");
  } finally {
    if (reloadButton) {
      reloadButton.textContent = originalLabel || "🔄 Boxen neu lernen";
      reloadButton.disabled = !isSessionAuthorized();
    }
    updateReloadButtonState();
  }
}
</script>
</body>
</html>
